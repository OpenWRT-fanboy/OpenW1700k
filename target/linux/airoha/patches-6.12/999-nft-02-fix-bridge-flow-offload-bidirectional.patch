From: Ryan Chen <rchen14b@gmail.com>
Subject: [PATCH] netfilter: nft_flow_offload: fix bridge flow offload for
 Airoha PPE

When bridged traffic passes through nft_flow_offload, the route tuple
contains the bridge interface (e.g., br-lan) rather than the physical
port interfaces. This prevents hardware flow offload engines like
Airoha PPE from properly accelerating bridge traffic, as they require
physical interface indices for FLOW_OFFLOAD_XMIT_DIRECT mode.

This patch captures the physical bridge port information from the
skb's nf_bridge_info (physinif/physoutif) and populates both
directions of the route tuple with the correct physical interface
indices and MAC addresses.

The fix handles two scenarios:

1. Simple untagged bridge (e.g., br-lan with eth0, lan1, lan2):
   - Direct offload with physical interface indices
   - No VLAN encapsulation needed

2. VLAN-tagged bridge (e.g., br-iptv with eth0.100):
   - Extracts VLAN ID from VLAN sub-interfaces
   - Populates encap[] array with VLAN info for PPE
   - Uses underlying physical device (e.g., eth0) for hw_ifindex
   - Sets ingress_vlans flag to prevent spurious VLAN_POP actions

Safety checks:
- Skip if original packet was VLAN-tagged (BRNF_PROTO_8021Q)
- Skip if route already has encapsulation setup
- Skip if physical devices are not Ethernet type

This enables hardware offload for both simple bridges and VLAN bridges,
while preserving kernel handling for complex nested VLAN scenarios.

Signed-off-by: Ryan Chen <rchen14b@gmail.com>
---
 net/netfilter/nft_flow_offload.c | 120 +++++++++++++++++++++++++++++++
 1 file changed, 120 insertions(+)

--- a/net/netfilter/nft_flow_offload.c
+++ b/net/netfilter/nft_flow_offload.c
@@ -10,6 +10,8 @@
 #include <linux/netfilter/nf_tables.h>
 #include <net/ip.h> /* for ipv4 options. */
 #include <net/inet_dscp.h>
+#include <linux/netfilter_bridge.h>
+#include <linux/if_vlan.h>
 #include <net/netfilter/nf_tables.h>
 #include <net/netfilter/nf_tables_core.h>
 #include <net/netfilter/nf_conntrack_core.h>
@@ -360,6 +362,124 @@
 	if (nft_flow_route(pkt, ct, &route, dir, priv->flowtable) < 0)
 		goto err_flow_route;
 
+	/*
+	 * Handle bridge flow offload for hardware acceleration.
+	 * This handles both simple bridges and VLAN-tagged bridges.
+	 *
+	 * For VLAN bridges (e.g., br-iptv with eth0.100), we extract
+	 * the VLAN ID and populate the encap array so PPE can handle
+	 * the VLAN tagging in hardware.
+	 */
+	{
+		const struct nf_bridge_info *nf_bridge = nf_bridge_info_get(pkt->skb);
+
+		if (nf_bridge && nf_bridge->physinif && nf_bridge->physoutdev) {
+			int physinif = nf_bridge->physinif;
+			struct net_device *physoutdev = nf_bridge->physoutdev;
+			struct net_device *physindev;
+			struct net_device *real_indev = NULL;
+			struct net_device *real_outdev = NULL;
+			u16 vlan_id_in = 0, vlan_id_out = 0;
+			bool can_offload = true;
+
+			/* Skip if original packet was already VLAN-tagged
+			 * (complex scenario, let kernel handle)
+			 */
+			if (nf_bridge->orig_proto == BRNF_PROTO_8021Q)
+				can_offload = false;
+
+			/* Skip if route already has encapsulation setup
+			 * (dev_fill_forward_path already handled it)
+			 */
+			if (can_offload &&
+			    (route.tuple[dir].in.num_encaps > 0 ||
+			     route.tuple[!dir].in.num_encaps > 0))
+				can_offload = false;
+
+			/* Skip if current device is not Ethernet */
+			if (can_offload &&
+			    (!pkt->skb->dev || pkt->skb->dev->type != ARPHRD_ETHER))
+				can_offload = false;
+
+			/* Get physical input device and check for VLAN */
+			rcu_read_lock();
+			physindev = dev_get_by_index_rcu(nft_net(pkt), physinif);
+			if (!physindev) {
+				can_offload = false;
+			} else if (is_vlan_dev(physindev)) {
+				vlan_id_in = vlan_dev_vlan_id(physindev);
+				real_indev = vlan_dev_real_dev(physindev);
+				if (!real_indev || real_indev->type != ARPHRD_ETHER)
+					can_offload = false;
+			}
+			rcu_read_unlock();
+
+			/* Check physical output device for VLAN */
+			if (can_offload && is_vlan_dev(physoutdev)) {
+				vlan_id_out = vlan_dev_vlan_id(physoutdev);
+				real_outdev = vlan_dev_real_dev(physoutdev);
+				if (!real_outdev || real_outdev->type != ARPHRD_ETHER)
+					can_offload = false;
+			}
+
+			if (can_offload) {
+				u8 pkt_h_source[ETH_ALEN];
+				u8 pkt_h_dest[ETH_ALEN];
+				bool macs_valid = false;
+				int hw_outif, hw_inif;
+
+				/* Determine hardware interface indices */
+				hw_outif = real_outdev ? real_outdev->ifindex : physoutdev->ifindex;
+				hw_inif = real_indev ? real_indev->ifindex : physinif;
+
+				if (skb_mac_header_was_set(pkt->skb)) {
+					struct ethhdr *eth = eth_hdr(pkt->skb);
+					memcpy(pkt_h_source, eth->h_source, ETH_ALEN);
+					memcpy(pkt_h_dest, eth->h_dest, ETH_ALEN);
+					macs_valid = true;
+				}
+
+				if (macs_valid && !is_zero_ether_addr(pkt_h_source) &&
+				    !is_zero_ether_addr(pkt_h_dest)) {
+					/* Setup forward direction (dir) */
+					memcpy(route.tuple[dir].out.h_source, pkt_h_source, ETH_ALEN);
+					memcpy(route.tuple[dir].out.h_dest, pkt_h_dest, ETH_ALEN);
+					route.tuple[dir].xmit_type = FLOW_OFFLOAD_XMIT_DIRECT;
+					route.tuple[dir].out.ifindex = physoutdev->ifindex;
+					route.tuple[dir].out.hw_ifindex = hw_outif;
+					route.tuple[dir].in.ifindex = physinif;
+					if (vlan_id_in) {
+						route.tuple[dir].in.encap[0].id = vlan_id_in;
+						route.tuple[dir].in.encap[0].proto = htons(ETH_P_8021Q);
+						route.tuple[dir].in.num_encaps = 1;
+						/*
+						 * Mark as ingress VLAN - the kernel VLAN driver
+						 * already stripped the tag on ingress. This
+						 * prevents VLAN_POP action for forward direction
+						 * while still allowing VLAN_PUSH for reverse.
+						 */
+						route.tuple[dir].in.ingress_vlans = BIT(0);
+					}
+
+					/* Setup reverse direction (!dir) */
+					memcpy(route.tuple[!dir].out.h_source, pkt_h_dest, ETH_ALEN);
+					memcpy(route.tuple[!dir].out.h_dest, pkt_h_source, ETH_ALEN);
+					route.tuple[!dir].xmit_type = FLOW_OFFLOAD_XMIT_DIRECT;
+					route.tuple[!dir].out.ifindex = physinif;
+					route.tuple[!dir].out.hw_ifindex = hw_inif;
+					route.tuple[!dir].in.ifindex = physoutdev->ifindex;
+					if (vlan_id_out) {
+						route.tuple[!dir].in.encap[0].id = vlan_id_out;
+						route.tuple[!dir].in.encap[0].proto = htons(ETH_P_8021Q);
+						route.tuple[!dir].in.num_encaps = 1;
+						/* Mark as ingress VLAN for reverse direction too */
+						route.tuple[!dir].in.ingress_vlans = BIT(0);
+					}
+				}
+			}
+		}
+	}
+
 	flow = flow_offload_alloc(ct);
 	if (!flow)
 		goto err_flow_alloc;
